## Solving

### Generic solver

* tests: solve full cube (max 7-8 moves?)
* more tests: eo and other stuff
* benchmarks

### Coordinates

* [done] eo
* co
* ep
* epsep
* cp
* cpsep
* cphtr

What about symcoord?

### More solvers

* solve_light: first based on solve_generic, then optimize; benchmark
  to see up to what length it works best (7 moves? 10 moves?)

### Implement the following solvers:

* Slow: basic solver without any table.
* H48: one-bit-per-entry table + fallback, 48 symmetries and so on.
  See planner.
* nxopt31: mostly for comparison.
* other nxopt solvers: make generic and take the type as parameter.
* Step solver: take a coordinate function and a moveset as a parameter.

### New method:

* 48 symmetries, cocsep (or chtr, or similar) + epsep + some EO
* 1 bit per entry + fallback
* store necessary stuff (e.g. ttrep) all interleaved in the same table

### Other considerations:

* Reconsider going corners-first, so there is no need to sumco()

## cube.h changes

* better documentation: add parameter names, one-line comment
  for each function
* prefix public functions with libnissy_ or something similar
* move() that takes a string (alg) as input
* readtrans() should work like readmoves (read multiple, return n)
* Add single moves and transformations to the interface? (performance!)
* More I/O:
  nissy
  ascii art (color = 1 letter)
  twizzle binary https://www.experiments.cubing.net/cubing.js/spec/binary/
  reid?

## Optimizations

* Trans: don't do full compose, for some trans composing perm is enough.
  Split out sumco() as a separate function and refactor, optimize.
* Use multi-move (up to 4/5 moves at once)
* CO is the worst part of moving, transforming and inverting. Try basing
  everything on representing the cube without CO and apply it only at the
  end to check that it is actually solved.
* see if vcube's method to flip all corners is better
* find a better way for computing the inverse?
* Improve avx2 instructions in general

## Improvements and other things

* NISS: Add mask to moves (e.g. U | NISS where NISS = 32 or something);
  adapt readmoves and writemoves.
* Consider adding centers and other moves (for avx2: centers in the
  same lane as corners, numbered from 9 to 14)
* rename to: libnissy? (also change all references to cube.c in doc)

## "Front-end"

* Write adapter code for other languages:
  python
  hare
  rust, go
  dart ffi, js
  java
* add also example code (e.g. an optimal solver) in examples/
* solver in C: use pthread_cancel
