## Benchmarks

The different type of benchmarks that need to be done are:

# Performance Benchmark

This benchmark measures the time taken by the algorithm to execute on the machine on a set of random positions with different depths. The time is compared with another modern solver (vcube) implemented with a similar dimension pruning table. This type of comparison can be made only with a x86 architecture machine because the vcube solver uses a Intel vectorization optimization. The data is generated by running the following command:

```
./benchmark performance
```

# SIMD Optimization Benchmark

This benchmark measures the gain in performance by using SIMD optimization. The result is measured by comparing the architecture-optimized code with the portable code. The data is generated by running the following command:

```
./benchmark architecture
```

# Pruning Memory Benchmark

This benchmark measures the performance of the algorithm with different sizes of pruning tables in order to assess which table is most suitable for our machine. The benchmarks runs the k2 version of the tables from the smallest (h0k2, 80MB) to a bigger one (h7k2, 4GB). The data is generated by running the following command:

```
./benchmark memory
```

# Nodes Benchmark 

This benchmark measures the number of nodes visited by the algorithm for different depths. The lower the number of nodes, the better the performance. Additionally, we compare the average time taken per node. This benchmark is run by using only one thread. The data is generated by running the following command:

```
./benchmark nodes
```

# Multi-threading Benchmark
This benchmark measures the performance of the algorithm with different numbers of threads. The  data is generated by running the following command:

```
./benchmark multithread
```

# Observations

We should take into consideration that the benchmarking is done on a primitive version of the solver. The solver is still under development, and the performance can be improved. The research done with this solver is to experiment with a different group considered in the pruning tables. We were uncertain if this technique would work better than the existing heuristics, but the results are quite close. The idea was to take advantage of the symmetries and reduced memory accesses of this group, while excluding other optimizations that could not be applied to it.